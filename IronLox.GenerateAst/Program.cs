using System.Text;

namespace IronLox.GenerateAst;

static class AssertionHelperExtension
{
    public static void Assert(this bool condition)
    {
        if (!condition) throw new ApplicationException("assertion failed");
    }
}

class Program
{
    const string DefaultOutputDirectory = "Ast";

    static void Main(string[] args)
    {
        if (args.Length > 1)
        {
            Console.Error.WriteLine("Usage: IronLox.GenerateAst <output_directory>");
            Environment.Exit(64);
        }
        var outputDirectory = args.Length == 0 ? DefaultOutputDirectory : args[0];


        DefineAst(outputDirectory, "IExpression", "IExpressionVisitor", [
            "Binary : IExpression left, Token @operator, IExpression right",
            "Grouping : IExpression expression",
            "Literal : object? value",
            "Unary : Token @operator, IExpression right",
        ]);
    }

    static void DefineAst(string outputDirectory, string rootInterfaceName, string visitorInterfaceName, IEnumerable<string> patterns)
    {
        // Write the `root` interface.
        WriteRootInterface(outputDirectory, rootInterfaceName);

        var typeNames = new List<string>();
        // Write types one by one.
        foreach (var pattern in patterns)
        {
            var (name, parameters) = Parse(pattern);
            var representation = new AstRepresentation(rootInterfaceName, visitorInterfaceName, name, parameters);
            typeNames.Add(representation.ClassName);
            Write(outputDirectory, representation);
        }

        WriteVisitorInterface(outputDirectory, visitorInterfaceName, typeNames);
    }

    static void WriteRootInterface(string outputDirectory, string interfaceName)
    {
        // Namespace section
        var builder = new StringBuilder("public interface ")
            .AppendLine(interfaceName)
            .AppendLine("{")
            .AppendLine("\tT Accept<T>(IVisitor<T> visitor);")
            .AppendLine("}");
        Write(outputDirectory, interfaceName, builder.ToString());
    }

    static void WriteVisitorInterface(string outputDirectory, string interfaceName, IEnumerable<string> typeNames)
    {
        var builder = new StringBuilder("public interface ")
            .Append(interfaceName)
            .AppendLine("<T>")
            .AppendLine("{");
        foreach (var typeName in typeNames)
        {
            builder.Append("\tT Visit(")
                .Append(typeName)
                .Append(" element")
                .AppendLine(");");
        }
        builder.AppendLine("}");
        Write(outputDirectory, interfaceName, builder.ToString());
    }

    static (string, IEnumerable<AstParameter>) Parse(string pattern)
    {
        var firstSplit = pattern.Split(':');
        (firstSplit.Length == 2).Assert();

        var typeName = firstSplit[0].Trim();
        var parameters = new List<AstParameter>();
        var secondSplit = firstSplit[1].Trim().Split(",");
        foreach (var segment in secondSplit)
        {
            var thirdSplit = segment.Trim().Split();
            (thirdSplit.Length == 2).Assert();

            parameters.Add(new(thirdSplit[0].Trim(), thirdSplit[1].Trim()));
        }
        return (typeName, parameters);
    }

    static void Write(string outputDirectory, AstRepresentation representation)
        => Write(outputDirectory, representation.ClassName, representation.ToString());

    static void Write(string outputDirectory, string name, string source)
    {
        if (!Directory.Exists(outputDirectory))
            Directory.CreateDirectory(outputDirectory);
        var path = Path.Combine(outputDirectory, $"{name}.cs");
        using var file = File.Create(path);
        using var bufferedStream = new BufferedStream(file);
        using var writer = new StreamWriter(bufferedStream);

        writer.WriteLine("/* Auto generated by IronLox.GenerateAst */");
        writer.WriteLine();
        writer.WriteLine($"namespace IronLox.{outputDirectory};");
        writer.WriteLine();
        writer.Write(source);
    }
}
