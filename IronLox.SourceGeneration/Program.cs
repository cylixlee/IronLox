using System.Text;

namespace IronLox.GenerateAst;

static class AssertionHelperExtension
{
    public static void Assert(this bool condition)
    {
        if (!condition) throw new ApplicationException("assertion failed");
    }
}

class Program
{
    const string DefaultOutputDirectory = "SyntaxTree";

    static void Main(string[] args)
    {
        if (args.Length > 1)
        {
            Console.Error.WriteLine("Usage: IronLox.SourceGeneration <output_directory>");
            Environment.Exit(64);
        }
        var outputEntry = args.Length == 0 ? DefaultOutputDirectory : args[0];

        // Expressions
        DefineSyntaxTree(outputEntry, "Expressions", "IExpression", "IExpressionVisitor", [
            "BinaryExpression : IExpression left, Token @operator, IExpression right",
            "GroupingExpression : IExpression expression",
            "LiteralExpression : object? value",
            "UnaryExpression : Token @operator, IExpression right",
        ]);

        // Statements
        DefineSyntaxTree(outputEntry, "Statements", "IStatement", "IStatementVisitor", [
            "ExpressionStatement : IExpression expression",
            "PrintStatement : IExpression expression",
        ]);
    }

    static void DefineSyntaxTree(
        string outputEntry,
        string subNamespace,
        string rootInterfaceName,
        string visitorInterfaceName,
        IEnumerable<string> patterns)
    {
        // Write the `root` interface.
        WriteRootInterface(outputEntry, rootInterfaceName, visitorInterfaceName);

        var nodeNames = new List<string>();
        // Write nodes one by one.
        foreach (var pattern in patterns)
        {
            var (nodeName, nodeParameters) = Parse(pattern);
            var node = new TreeNode(rootInterfaceName, visitorInterfaceName, nodeName, nodeParameters);
            nodeNames.Add(nodeName);
            Write(outputEntry, node, subNamespace);
        }

        WriteVisitorInterface(outputEntry, visitorInterfaceName, nodeNames);
    }

    static void WriteRootInterface(string outputEntry, string rootInterfaceName, string visitorInterfaceName)
    {
        // Namespace section
        var builder = new StringBuilder("public interface ")
            .AppendLine(rootInterfaceName)
            .AppendLine("{")
            .AppendLine($"\tT Accept<T>({visitorInterfaceName}<T> visitor);")
            .AppendLine("}");
        Write(outputEntry, rootInterfaceName, builder.ToString());
    }

    static void WriteVisitorInterface(string outputEntry, string visitorInterfaceName, IEnumerable<string> nodeNames)
    {
        var builder = new StringBuilder("public interface ")
            .Append(visitorInterfaceName)
            .AppendLine("<T>")
            .AppendLine("{");
        foreach (var nodeName in nodeNames)
        {
            builder.Append("\tT Visit(")
                .Append(nodeName)
                .Append(" element")
                .AppendLine(");");
        }
        builder.AppendLine("}");
        Write(outputEntry, visitorInterfaceName, builder.ToString());
    }

    static (string, IEnumerable<TreeNodeParameter>) Parse(string pattern)
    {
        var firstSplit = pattern.Split(':');
        (firstSplit.Length == 2).Assert();

        var nodeName = firstSplit[0].Trim();
        var nodeParameters = new List<TreeNodeParameter>();
        var secondSplit = firstSplit[1].Trim().Split(",");
        foreach (var segment in secondSplit)
        {
            var thirdSplit = segment.Trim().Split();
            (thirdSplit.Length == 2).Assert();

            nodeParameters.Add(new(thirdSplit[0].Trim(), thirdSplit[1].Trim()));
        }
        return (nodeName, nodeParameters);
    }

    static void Write(string outputEntry, TreeNode representation, string? subNamespace = null)
        => Write(outputEntry, representation.ClassName, representation.ToString(), subNamespace);

    static void Write(string outputEntry, string name, string source, string? subNamespace = null)
    {
        if (!Directory.Exists(outputEntry))
            Directory.CreateDirectory(outputEntry);

        var path = Path.Combine(outputEntry, $"{name}.cs");
        if (subNamespace is not null)
        {
            var subNamespacePath = Path.Combine(outputEntry, subNamespace);
            if (!Directory.Exists(subNamespacePath))
                Directory.CreateDirectory(subNamespacePath);
            path = Path.Combine(subNamespacePath, $"{name}.cs");
        }

        using var file = File.Create(path);
        using var bufferedStream = new BufferedStream(file);
        using var writer = new StreamWriter(bufferedStream);

        writer.WriteLine("/* Auto generated by IronLox.SourceGeneration */");
        writer.WriteLine();
        if (subNamespace is not null)
            writer.WriteLine($"namespace IronLox.{outputEntry}.{subNamespace};");
        else writer.WriteLine($"namespace IronLox.{outputEntry};");
        writer.WriteLine();
        writer.Write(source);
    }
}
